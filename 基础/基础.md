# 基础算法

## 一、欧几里得算法求公约数

```c
#include <stdio.h>
int gcd(int a,int b){
	int temp;
	while (b)
	{
		temp = a % b;
		a = b;
		b = temp;
	}
	return a;
}
int main(int argc, char *argv[])
{
	int a, b;
	printf("please input the number a and b:\n");
	printf("a = ");
	scanf("%d",&a);
	printf("b = ");
	scanf("%d",&b);
	printf("The gcd of a(%d) and b(%d) is %d.\n",a,b,gcd(a,b));
	return 0;
}
```
## 二、筛法求素数
> 用筛法求素数的基本思想是：把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。
### 算法
欲筛法求素数，先构造n以内的素数表：

1. x从1开始，判断x是否为素数

2. 若x为素数，则筛去x的小于n的所有倍数

   若x不为素数，跳过此步骤

3. x++，直至x<n

然，从表中判断。

### 示例程序

```c
int main(int argc, char *argv[])
{
	const int MAX = 1e6;
	bool isPrime[MAX];
	int number;
	// 开辟prime[MAX]，初始其所有元素为1，prime[x]为true表示x是素数
	for (int i = 0; i < MAX; i++)
		isPrime[i] = true;
	for (int x = 2; x < MAX; x++)
	{
		if (isPrime[x])
			for (int i = 2; i * x < MAX; i++)
				isPrime[i * x] = false;
	}
	printf("please input the number you want to know whether it's a prime:\n");
	scanf("%d", &number);
	if (isPrime[number])
		printf("It's a prime!\n");
	else
		printf("It isn't a prime!\n");
	return 0;
}
```

## 三、康托展开

> **康托展开**是一个全排列到一个[自然数](https://baike.baidu.com/item/自然数)的[双射](https://baike.baidu.com/item/双射)，常用于构建[哈希表](https://baike.baidu.com/item/哈希表)时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。（[百度百科](https://baike.baidu.com/item/康托展开)）

### 通俗理解

康托展开可以求解一个排列的序号，比如：12345 序号为 1 ，12354序号为2，按字典序增加编号递增，依次类推。
康托逆展开可以求解一个序号它对应的排列是什么。

### 康托展开公式

给定一个全排列，计算其字典序。直观起见，我们举例[2, 3, 4, 1]来说明康托展开的运作步骤：

命所求字典序为 `rank = 0`

1. 第1位是2，那么以 1 打头的所有全排列一定排在这个全排列之前，以 1 打头的全排列有 (3!) = 6种。`rank += 1*3! = 6`
2. 第 2 位是 3，那么以 1 与 2 作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不需要再考虑 2 占第二位的情况，只需要计算 1 占第二位的情况。`rank += 1*2!= 8 `
3. 第3位是 4，同时，我们计算以 1 占第三位的所有情况。`rank += + 1∗1! = 9`
4. 最后一位，是不需要判定的，因为前 n−1 位给定后，第 n 位自定。`rank += + 0∗0! = 9`

由是，排在 [2, 3, 4, 1] 之前的全排列共有 9 个，那么 [2, 3, 4, 1] 应当是第 **10** 个全排列。

总结康托展开公式为：

$$
rank=a_{n}(n-1) !+a_{n-1}(n-2) !+\cdots+a_{1} \cdot 0 !
$$
其中，$a_i$ 表示原排列中，排在下标 i 后面的，比下标 i 的字符还小的字符个数。当然，如果排名是从 1 开始的话，最终结果应当再 + 1。

<p align="right">资料来源:<a href="https://blog.csdn.net/ajaxlt/article/details/86544074">CSDN</a></p>

### 示例代码

```c
const int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}; //	0-10的阶乘
//cantor展开，n表示是n位的全排列，a[]表示全排列的数(用数组表示)
int cantor(int a[], int n)
{
	int ans = 0, sum = 0;
	for (int i = 1; i < n; i++)
	{
		for (int j = i + 1; j <= n; j++)
		{
			if (a[j] < a[i])
				sum++;
		}
		ans += sum * fact[n - i]; //	累积
		sum = 0;				  //	计数器归零
	}
	return (ans + 1);
}
```

