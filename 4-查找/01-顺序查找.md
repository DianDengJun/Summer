# 一般线性表的顺序查找

基本思想：从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，还没有查找到符合给定条件的元素，则返回查找失败的信息。

下面的简单的算法实现，【引入了“ 哨兵 ”】

```c
typedef struct{                   // 查找表的数据结构
   ElemType  *elem;               // 元素存储空间基址，建表时按实际长度分配，0号单元留空
   int  TableLen;                 // 表的长度[从1号单元开始计数]           
}SSTable;
 
// 在顺序表 ST 中顺序查找关键字为 key 的元素。若找到则返回该元素在表中的位置
int Search_Seq(SSTable ST , ElemType key){
    
       // 将即将需要查找的关键字放在 ST 的第 0 个位置，作为 “ 哨兵 ”
       ST.elem[0] = key ;
 
       // 记录查找到的元素在查找表中的位置
       int location ;
 
        // 循环遍历查找表中的数据，判断是否存在需要的 key
        for(  location = ST.TableLen ; ST.elem[location] != key ; --location ){
            
 
        }
 
        //返回 location 
        //如果 location 此时的值为 0 ， 则表示在表中没有查找到
        //如果 location 此时的值为 非0 ， 则表示在表中查找到了所需要的元素
         
        return location ; 
 
}
```

+ 补充1：在上面的算法中，ST.elem[0] 称为“ 哨兵” 。引入的目的是为了使得 Search_Seq 内的循环不必判断数组是否会越界，因为当满足 location = 0 的时候，循环一定会跳出。

+ 补充2：**通过引入“ 哨兵 ” ，可以避免很多不必要的判断语句，从而提高程序效率**。

+ 顺序查找的缺点：当 n 较大的时候，平均查找长度较大，效率低；
+ 顺序查找的优点：对数据元素的存储没有要求，顺序存储或者链式存储皆可。