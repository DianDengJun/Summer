# 非递减数列

+ 难度：简单
+ 标签：`数组`
+ 链接：力扣 https://leetcode-cn.com/problems/non-decreasing-array

## 题目

给你一个长度为 `n` 的整数数组，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 `i` `(0 <= i <= n-2)`，总满足 `nums[i] <= nums[i + 1]`。

 

**示例 1:**

```
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
```

**示例 2:**

```
输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
```

**说明：**

+ `1 <= n <= 10 ^ 4`

- `10 ^ 5 <= nums[i] <= 10 ^ 5`

## 解答记录

1，2，4，8，5，4，9

从左至右遍历数组：

+ `if (nums[i] > nums[i+1] )` ，此时不是非递减序列，将要修改一个数。

  若 `nums[i] <= nums[i+2]` ，可以修改 `nums[i]` ；

  若 `num[i-1] >= nums[i+1]` ，可以修改 `nums[i+1]` 。

+ 无需实际修改，只记录是否修改过（修改过一次就不能再修改了）

```c
bool checkPossibility(int* nums, int numsSize){
    bool changed = false;
    for(int i = 0; i < numsSize - 1; i++){
        if(nums[i] > nums[i+1]) {
            if(changed) return false;
            if(i > 0 && i < numsSize - 2 && nums[i] > nums[i+2] && nums[i-1] > nums[i+1])
                return false;
            changed = true;
        }
    }
    return true;
}
```

返回信息：

+ 用时 36 ms，击败 27.82% 的 C 提交；
+ 内存消耗 6.5 MB，击败 71.79% 的 C 提交；

## 官方解答赏析

> come from: https://leetcode-cn.com/problems/non-decreasing-array/solution/fei-di-jian-shu-lie-by-leetcode/

### 方法一：暴力法
对于给定的数组 A，若最多更改一个元素 A[i]，则应将 A[i] 更改为 A[i-1]，因为这样可以保证 A[i-1]≤A[i]，并且 A[i] 是实现 A[i]≤A[i+1] 的最小可能值。

**算法：**
对于数组中每个元素 A[i]，更改 A[i] 并检查序列是否单调递增。我们将在 new 上修改，这是数组 A 的副本。

**复杂度分析**

+ 时间复杂度：N 为给定数组的长度。对于每个元素 A[i]，我们检查某个序列是否单调递增，这需要 O(N) 的时间复杂度。总的来说，总时间复杂度为 $O(N^2)$ 。
+ 空间复杂度：O(N) ，使用了一个大小为 N 的数组 new 。

### 方法二：分解成子问题
如果 A[0]≤A[1]≤A[2]，则可以删除 A[0]。同样，如果 A[len(A)-3]≤A[len(A)-2]≤A[len(A)-1]，我们可以删除 A[len(A)-1]。

**算法：**

考虑子数组 [A[i]，A[i+1]，…，A[j]] 相对应的间隔 [i, j]。当 a[i]≤a[i+1]≤a[i+2] 时，我们知道不需要修改 A[i]，我们可以考虑在 [i+1，j] 间隔上解决问题。我们对 j 也使用类似的方法。
之后，考虑的区间长度是 j - i + 1，如果区间大小为 2 或更小，那么原序列是非递减数列。
如果我们考虑的区间有 5 个或更多的元素，那么有两个不相交的问题不能用一个替换来解决。
所以我们考虑的区间大小最多是 4 个元素，在最多改变 1 个元素的情况下变成一个非递减数列。
**复杂度分析**

时间复杂度：NN 为给定数组的长度。我们的指针 i 和 j 最多移动 O(N) 次且考虑的数组中最多有 4 个元素。因此，复杂性为 O(N)。
空间复杂度：使用的是常量空间，空间复杂度为 O(1)。

### 方法三：查找问题索引

考虑 A[p]>A[p+1] 的所有索引 p 。如果没有这样的索引 p，则返回 `True`。如果有 2 个或更多，则返回 `False`，因为有多少个这样的索引 `p`,就需要更改多少个元素。

在问题索引 p 中，我们只关心周围的元素。因此，这个问题被简化成一个非常小的子问题来进行分析。

**算法：**
如前所述，设 p 为 A[p]>A[p+1] 的唯一问题索引。如果这不是唯一的或不存在，则答案分别为 `False` 或 `True` 。我们分析了以下情况：

+ 如果 p = 0，那么我们可以通过设置 A[p] = A[p+1] 使数组变成非递减数列。
+ 如果  p = len(A) - 2，则可以通过设置  A[p+1] = A[p] 使数组变成非递减数列。
+ 否则，A[p-1], A[p], A[p+1], A[p+2] 都存在，并且：
  1. 如果可能的话，我们可以将 A[p] 更改为 A[p-1] 和 A[p+1] 之间。
  2. 如果可能的话，我们可以将 A[p+1] 更改为 A[p] 和 A[p+2] 之间的值。

**复杂度分析**

+ 时间复杂度：N 为给定数组的长度。我们循环一次数组，所以我们的时间复杂度是 O(N)。
+ 空间复杂度：我们只使用 p 和 i，空间复杂度是 O(1)。

---

<p align="center">COPYRIGHT © 2020 <a href="https://www.xxdiandeng.cn">DianDengJun</a>. | All Rights Reserverd.</p>