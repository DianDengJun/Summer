# 冒泡排序算法

## 要求

输入n个整数，将它们从小到大排序后输出，要求使用冒泡排序算法。

## 示例源代码

```c
/*冒泡排序算法*/
#include <stdio.h>
void bubble(int a[], int n);

int main()
{
	int n, a[8];
	int i;

	printf("Enter n (n<=8) :");
	scanf("%d", &n);
	printf("Enter a[%d]:", n);
	for (i = 0; i < n; i++)
		scanf("%d", &a[i]);
	bubble(a, n);
	printf("After sorted, a[%d] = ", n);
	for (i = 0; i < n; i++)
		printf("%3d", a[i]);
	return 0;
}

void bubble(int a[], int n) 		//n是数组a中待排序元素的数量
{
	int i, j, t;
	for (i = 1; i < n; i++)			//外部循环
		for (j = 0; j < n - 1; j++) //内部循环
			if (a[j] > a[j + 1])	//比较两个元素的大小
			{
				//如果前一个元素大，则交换
				t = a[j];
				a[j] = a[j + 1];
				a[j + 1] = t;
			}
}
```

### 运行结果

```
Enter n (n<=8) :8

Enter a[8]:7 3 66 3 -5 22 -77 2

After sorted, a[8] = -77 -5 2 3 3 7 22 66
```

## 算法分析

对于搜索大型数据库来说，对数据进行排序的算法是至关重要的。用词典来查找字词是相对容易和方便的，这是因为词典按字母表顺序排了序。排序（sort）是一种非常有助于解决查找问题的技术，此外，如何有效的排序本身就是计算机算法的一个重要研究领域。
之所以叫做冒泡排序，是因为在进行从小到大排序时，小的数经过交换会慢慢从底下“冒”上来。冒泡排序效率不高，这是因为他需要约$\frac{n^2}{2}$次比较。然而对一些小数组来说，它的性能通常还是可以接受的。对于数组 `a` ，假定输入后值为 `{7, 3, 66, 3, -5, 22, -77, 2}` ，再调用 `bubble(a,8)` 。下表给出了在每次外部循环后数组a中的元素。

|              | a[0] | a[1]   | a[2]  | a[3]  | a[4]  | a[5]  | a[6]   | a[7]   |
| ------------ | ---- | ------ | ----- | ----- | ----- | ----- | ------ | ------ |
| 未排序的数据 | 7    | 3      | 66    | 3     | -5    | 22    | -77    | 2      |
| 第1遍        | 3    | 7      | 3     | -5    | 22    | -77   | 2      | **66** |
| 第2遍        | 3    | 3      | -5    | 7     | -77   | 2     | **22** | **66** |
| 第3遍        | 3    | -5     | 3     | -77   | 2     | **7** | **22** | **66** |
| 第4遍        | -5   | 3      | -77   | 2     | **3** | **7** | **22** | **66** |
| 第5遍        | -5   | -77    | 2     | **3** | **3** | **7** | **22** | **66** |
| 第6遍        | -77  | -5     | **2** | **3** | **3** | **7** | **22** | **66** |
| 第7遍        | -77  | **-5** | **2** | **3** | **3** | **7** | **22** | **66** |

在第一次循环的开始处，把 `a[0]` 与 `a[1]` 比较，由于它们不符合次序要求，对它们要做交换；然后把 `a[1]` 与 `a[2]` 比较，由于它们符合次序要求，对他们不做交换；再把 `a[2]` 与 `a[3]` 比较，依此类推。若邻接元素不符合次序要求，则要求对它们进行交换。第一次循环的效果是把数组中的最大元素“冒泡”到 `a[7]` 。在第二次循环后，不再检查a[7]，即不再改变它，把 `a[0]` 再与 `a[1]`比较，如此等等。在第二次循环后，第二大的数存放在  `a[6]`  中。由于每次循环都把当前最大的元素放在数组的合适位置，在 `n-1` 次循环后，算法就完成了所有元素的排序。

> 排序是程序算法中非常有挑战意义的，这里给出的冒泡排序和[选择排序法](https://www.xxdiandeng.cn/2020/06/25/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/)从效率上讲都不是很高，实际需要的排序时间也很长，特别是在数据量很大的情况下更是耗费时间。请读者改进冒泡排序算法，以提高算法的效率，这也有助于进一步理解程序设计算法以及指针和数组的使用。

<p align="right">摘自高等教育出版社《C语言程序设计（第3版）》（何钦铭，颜晖主编）</p>

----

<p align="center">COPYRIGHT © 2020 <a href="https://www.xxdiandeng.cn">DianDengJun</a>. | All Rights Reserverd.</p>